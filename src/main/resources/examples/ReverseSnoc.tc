/*
 * Equiv step for:
 *
 *   rev (l :+ y) = y :: (rev l)
 */

f ?y = rev (l :+ y)   [++]
g ?y = y :: rev(l)   [++]

rev ?l = l match ((⟨⟩ => ⟨⟩) / ((?x :: ?xs) => (rev xs) :+ x))     /* (defn) */

l = z :: x :: nil

// ltwf xs l = ⊤  [++]

// ltwf ?t l ||> rev (t :+ ?w) >> w :: rev t     /* IH */

rev (_ :+ _) -> _ :: (rev _)
