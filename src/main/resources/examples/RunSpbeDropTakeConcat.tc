drop ?i ?l = l match ((⟨⟩ => ⟨⟩) / ((?x :: ?xs) => i match ((zero => (x::xs)) / ((suc ?j) => (drop j xs))))) [notypes]
take ?i ?l = l match ((⟨⟩ => ⟨⟩) / ((?x :: ?xs) => i match ((zero => nil) / ((suc ?j) => (x::(take j xs)))))) [notypes]

concat ?l1 ?l2 >> l1 ++ l2 [typedlet]
l1 ++ l2 >> concat ?l1 ?l2 [notypes]

cons ?x ?l >> x :: l [typedlet]
?x :: ?l >> cons ?x ?l [notypes]

drop ?i (?x :: ?xs) |>> splitTrue ||| possibleSplit(i, zero, (suc ?j)) [notypes]
take ?i (?x :: ?xs) |>> splitTrue ||| possibleSplit(i, zero, (suc ?j)) [notypes]

SPBE( ⟨⟩ , (cons : int :> list int :> list int) ) ((concat : list int :> list int :> list int), (drop: int :> list int :> list int), (take: int :> list int :> list int)) 2 4 2 1 2 1

f = take l i ++ drop l i [++]
f >> l
