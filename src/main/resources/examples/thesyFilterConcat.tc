filter ?p ?l = l match ((⟨⟩ => ⟨⟩) / ((?x :: ?xs) => (p x) match ((true =>  x :: (filter p xs)) / (false => filter p xs)))) [notypes]

concat ?l1 ?l2 >> l1 ++ l2
l1 ++ l2 >> concat ?l1 ?l2 [notypes]

cons ?x ?l >> x :: l
?x :: ?l >> cons ?x ?l [notypes]

filter ?p (?x :: ?xs) |>> splitTrue ||| possibleSplit((p x), true, false) [notypes]

thesy (list,) ((filter : (int :> boolean) :> list int :> list int), (concat : list int :> list int :> list int)) 2 4 3 2

concat (filter p l1) (filter p l2) = f l1 l2   [++]
concat (filter p l1) (filter p l2) -> filter p (concat l1 l2)

// Start time: Wed Dec 11 15:46:07 IST 2019
// End time: Wed Dec 11 16:14:39 IST 2019