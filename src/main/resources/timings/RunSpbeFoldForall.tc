//and ?x ?y = x match ((true => id y) / (false => false)) [notypes]
//or ?x ?y = x match ((true => true) / (false => id y)) [notypes]
//not ?x = x match ((true => false) / (false => true)) [notypes]
//Not ?p ?x = not(p x)
forall ?l = l match ((⟨⟩ => true) / ((?x :: ?xs) => and x (forall xs))) [notypes]
exists ?l = l match ((⟨⟩ => false) / ((?x :: ?xs) => or x (exists xs))) [notypes]
fold ?f ?i ?l = l match ((⟨⟩ => id i) / ((?x :: ?xs) => fold f (f(x,i)) xs)) [notypes]

Cons ?x ?l >> x :: l [typedlet]
?x :: ?l >> Cons ?x ?l [notypes]

and ?x ?y >> and ?y ?x
and ?x (and ?y ?z) = and (and ?x ?y) ?z
and false ?x >> false
and true ?x >> id ?x

or ?x ?y >> or ?y ?x
or ?x (or ?y ?z) = or (or ?x ?y) ?z
or false ?x >> id ?x
or true ?x >> true

// or ?x ?y |>> splitTrue ||| possibleSplit(x, true, false) [typedlet]
// and ?x ?y |>> splitTrue ||| possibleSplit(x, true, false) [typedlet]

thesy( ⟨⟩ , (cons : boolean :> list boolean :> list boolean) ) (true, (forall : list boolean :> boolean), (and : boolean :> boolean :> boolean), (fold : (boolean :> boolean :> boolean) :> boolean :> (list boolean) :> boolean)) 3 8 0