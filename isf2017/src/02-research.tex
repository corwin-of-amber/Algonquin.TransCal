\section{Research Objective and Expected Significance}

This research aims to improve the productivity of software development
as well as the quality of the developed code by promoting a new style
of \emph{gradual programming by refinement}.
% explain why refinement is great etc.

\begin{paragraph}{Challenges}
The process becomes more interactive with the programmer and the
compiler taking turns. Correctness should be preserved at all times
to deliver useful abstractions.
Smaller steps allow more interactivity but require more programmer
effort; large steps increase automation but create higher latency
and may not generalize well.
\end{paragraph}

% sub paragraph
\begin{paragraph}{Separation of Concerns}
Effective abstractions simplify the thought process of putting together
a piece of software by ignoring some of the aspects of it, focusing on
one concern at a time. This allows the developer to filter out background
noise and pay attention to all the different functionality requirements.
Previous approaches to \emph{aspect-oriented programming} recognized this
difficulty and were able to separate away e.g. the logging layer or error
handling policy of the application. Their biggest shortcomings were 
(i) being overly attached to the language syntax rather than semantics, 
(ii) providing a rather thin white-box interface between modules
    (so-called \emph{aspects}), and
(iii) committing to the orthodox batch-compilation development cycle.
To overcome these obstacles, we have to define a richer meta-programming
language that can reason about computation at the semantic level.
\end{paragraph}

% sub paragraph
\begin{subparagraph}{Bridging the Performance Gap}
One of the rules-of-thumb in OOP encapsulation is that a caller module
does not have to be concerned with how specific methods of the callee are
implemented. In practice, performance concerns affect and sometimes dominate
the design of library APIs.
The reason is the poverty of ways to compose programs, the most common of
which are \emph{message passing}-based mechanisms --- procedure calls,
asynchronous events, dynamic dispatch, actors, etc. are all instances of
this rather basic, operational approach.
Some programs are not written to begin with because they are considered
by the developer as sub-optimal or even na\"ive.
However, na\"ive programs provide ideal abstractions by ignoring performance.
Of course, to allow such programs into existence means that the compiler
has to work harder, perhaps interactively with the human, to overcome the
problems of prohibitively high resource usage that will emerge as a result.
\end{subparagraph}

% sub paragraph
\begin{subparagraph}{HCI and Visual Representation Issues}
Even a small number of refinements can lead to many different choices
during the development and refinement process.
While various heuristics can commonly be applied to choose between them,
there is need for occasional human intervention.
Since it is not possible to simply list the alternatives, a more accessible
medium is required to allow users to receive feedback from both successful
and failed refinement steps, and to sift through a pile of mostly-similar
program terms to get just the right one.
\end{subparagraph}