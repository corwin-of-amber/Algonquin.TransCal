\section{Research Objective and Expected Significance}

This research aims to improve the productivity of software development
as well as the quality of the developed code by promoting a new style
of \emph{gradual programming by refinement}.
% explain why refinement is great etc.
This allows rapid prototyping by ignoring some aspects of the system
(especially, its resource usage).
Such aspects are not left unaddressed, but are later dealt with by refining
the first revision using formal tools.
In this way, developers would produce higher quality code faster;
the resulting code will be easier to read and maintain;
consequently, it becomes more reusable since it has a clear semantic structure
rather than a flat API.
That means that individual modules can be incorporated into new code,
a process which today requires a great amount of tedious, menial labor.

\begin{paragraph}{Challenges}
We envision the development process becoming more interactive with the programmer and the
compiler taking turns. Correctness should be preserved at all times
to deliver useful abstractions.
Smaller steps allow more interactivity but require more programmer
effort; large steps increase automation but create higher latency
and may not generalize well.
This opens up a whole area of trade-offs in the design of such interactions.
\end{paragraph}


\begin{subparagraph}{Separation of Concerns}
Effective abstractions simplify the thought process of putting together
a piece of software by decomposing the problem, focusing on
one concern at a time. This allows the developer to filter out background
noise and pay attention to all the different functionality requirements.
Previous approaches to \emph{aspect-oriented programming} recognized this
difficulty and were able to separate away \eg the logging layer or error
handling policy of the application. Their biggest shortcomings were 
\begin{enumerate*}[label=(\textit{\roman*})]
\item
being overly attached to the language syntax rather than semantics, 
\item
providing a rather thin white-box interface between modules
    (so-called \emph{aspects}), and
\item 
committing to the orthodox batch-compilation development cycle.
To overcome these obstacles, we have to define a richer meta-programming
language that can reason about computation at the semantic level.
\end{enumerate*}
\end{subparagraph}


\begin{subparagraph}{Bridging the Performance Gap}
One of the rules-of-thumb in OOP encapsulation is that a caller module
does not have to be concerned with how specific methods of the callee are
implemented. In practice, performance concerns affect and sometimes dominate
the design of library APIs.
The reason is the poverty of ways to compose programs, the most common of
which are \emph{message passing}-based mechanisms --- procedure calls,
asynchronous events, dynamic dispatch, actors, etc. are all instances of
this rather basic, operational approach.
Some programs are not written to begin with because they are considered
by the developer as sub-optimal or even na\"ive.
However, na\"ive programs provide ideal abstractions by ignoring performance.
Of course, to allow such programs into existence means that the compiler
has to work harder, perhaps interactively with the human, to overcome the
problems of prohibitively high resource usage that will emerge as a result.
\end{subparagraph}


\begin{subparagraph}{HCI and Visual Representation Issues}
Even a small number of refinements can lead to many different choices
during the development and refinement process.
While various heuristics can commonly be applied to choose between them,
there is need for occasional human intervention.
Since it is not possible to simply list the alternatives, a more accessible
medium is required to allow users to receive feedback from both successful
and failed refinement steps, and to sift through a pile of mostly-similar
program terms to get just the right one.
\end{subparagraph}