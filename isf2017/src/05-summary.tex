\section{Summary}

Computer scientist of the late 80's, judging by their papers, believed that
automated programming is just around the corner.
Indeed, the programming languages community has produced a vast variety of
languages and tools; but also the demands of the software industry and the
complexity of programmatic problems we face are much higher.
Computing architectures have also grown more versatile and subtle, as have
networking solutions, and the task at hand involves knowledge of memory
hierarchies, hardware and software APIs, various protocols, libraries,
frameworks, stacks, etc.
This knowledge is not stored anywhere but rests in experienced programmers'
heads; this is highly undesirable since humans are not adapted to handling
a large number of small details with many cross-dependencies --- computers
are. Human developers should be doing the abstract and creative thinking.
To pass the former part to computers an appropriate formalism for representing
it has to be built first.
This project holds an attempt at bottom-up characterization of such candidate
formalisms, so that tedious programming and debugging tasks can be loaded
off to computer programs, the same way compilers took over machine code
and assembly.
